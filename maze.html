<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  height: 100%;
  background: #0b1426;
  color: #eaf2ff;
  font-family: "Pretendard", sans-serif;
  text-align: center;
}

/* ì œëª© + ë²„íŠ¼ */
.header {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 12px;
  z-index: 50;
}

.header h1 {
  margin: 0;
  font-size: 20px;
  color: #ffd447;
}

#generateBtn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #ffd447;
  color: #1a1300;
  font-weight: 700;
  cursor: pointer;
}
#generateBtn:hover { opacity: 0.9; }

/* ìº”ë²„ìŠ¤ */
#mazeCanvas {
  width: 100% !important;
  height: 100% !important;
  display: block;
  background: #0a1225;
  border-top: 60px solid transparent; /* ì œëª©/ë²„íŠ¼ ê³µê°„ í™•ë³´ */
}

/* ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± */
#joystick {
  position: fixed;
  bottom: 40px;
  left: 40px;
  width: 140px;
  height: 140px;
  background: rgba(255,255,255,0.07);
  border: 2px solid rgba(255,255,255,0.15);
  border-radius: 50%;
  touch-action: none;
  z-index: 999;
}
#stick {
  position: absolute;
  width: 60px;
  height: 60px;
  background: rgba(255,212,71,0.85);
  border-radius: 50%;
  left: 40px;
  top: 40px;
  transition: 0.05s;
  touch-action: none;
}
</style>
</head>

<body>

<div class="header">
  <h1>ğŸŒ€ ëœë¤ ë¯¸ë¡œ ê²Œì„</h1>
  <button id="generateBtn">ğŸ”„ ìƒˆ ë¯¸ë¡œ</button>
</div>

<canvas id="mazeCanvas"></canvas>

<!-- ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± -->
<div id="joystick"><div id="stick"></div></div>

<script>
// =========================
// ìº”ë²„ìŠ¤ ì„¤ì • (ë°˜ì‘í˜•)
// =========================
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");

let rows = 25;
let cols = 25;
let cellSize = 20;

let grid = [];
let stack = [];
let player = { r: 0, c: 0 };
let exit = { r: rows - 1, c: cols - 1 };

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // cellSize ë³´ì •
  cellSize = Math.floor(canvas.width / cols);
  if (cellSize * rows > canvas.height - 60) {
    cellSize = Math.floor((canvas.height - 60) / rows);
  }
  if (cellSize < 4) cellSize = 4;

  drawMaze();
}

window.addEventListener("resize", () => {
  resizeCanvas();
});


// =========================
// ì…€ êµ¬ì¡°
// =========================
class Cell {
  constructor(r, c) {
    this.r = r;
    this.c = c;
    this.walls = { top: true, right: true, bottom: true, left: true };
    this.visited = false;
  }

  draw() {
    const x = this.c * cellSize;
    const y = this.r * cellSize + 60; // ì œëª© ê³µê°„ í™•ë³´

    ctx.strokeStyle = "#eaf2ff";
    ctx.lineWidth = 2;

    if (this.walls.top)    drawLine(x, y, x + cellSize, y);
    if (this.walls.right)  drawLine(x + cellSize, y, x + cellSize, y + cellSize);
    if (this.walls.bottom) drawLine(x, y + cellSize, x + cellSize, y + cellSize);
    if (this.walls.left)   drawLine(x, y, x, y + cellSize);
  }
}

function drawLine(x1,y1,x2,y2) {
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();
}


// =========================
// DFS ë¯¸ë¡œ ìƒì„±
// =========================
function generateMaze() {
  grid = [];
  stack = [];

  for (let r = 0; r < rows; r++) {
    let row = [];
    for (let c = 0; c < cols; c++) {
      row.push(new Cell(r, c));
    }
    grid.push(row);
  }

  let current = grid[0][0];
  current.visited = true;
  stack.push(current);

  while (stack.length > 0) {
    let next = checkNeighbors(current);

    if (next) {
      next.visited = true;
      stack.push(current);
      removeWalls(current, next);
      current = next;
    } else {
      current = stack.pop();
    }
  }
}

function checkNeighbors(cell) {
  let { r, c } = cell;
  let neighbors = [];

  if (r > 0 && !grid[r - 1][c].visited) neighbors.push(grid[r - 1][c]);
  if (c < cols - 1 && !grid[r][c + 1].visited) neighbors.push(grid[r][c + 1]);
  if (r < rows - 1 && !grid[r + 1][c].visited) neighbors.push(grid[r + 1][c]);
  if (c > 0 && !grid[r][c - 1].visited) neighbors.push(grid[r][c - 1]);

  if (neighbors.length === 0) return undefined;
  return neighbors[Math.floor(Math.random() * neighbors.length)];
}

function removeWalls(a, b) {
  let dx = a.c - b.c;
  let dy = a.r - b.r;

  if (dx === 1) { a.walls.left = false; b.walls.right = false; }
  else if (dx === -1) { a.walls.right = false; b.walls.left = false; }

  if (dy === 1) { a.walls.top = false; b.walls.bottom = false; }
  else if (dy === -1) { a.walls.bottom = false; b.walls.top = false; }
}


// =========================
// ë¯¸ë¡œ + í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
// =========================
function drawMaze() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  grid.forEach(row => row.forEach(cell => cell.draw()));

  // í”Œë ˆì´ì–´
  drawCircle(
    player.c * cellSize + cellSize/2,
    player.r * cellSize + cellSize/2 + 60,
    cellSize/3,
    "#68c3ff"
  );

  // ì¶œêµ¬
  drawCircle(
    exit.c * cellSize + cellSize/2,
    exit.r * cellSize + cellSize/2 + 60,
    cellSize/3,
    "#ffd447"
  );
}

function drawCircle(x,y,r,color){
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fillStyle = color;
  ctx.fill();
}


// =========================
// ì´ë™(WASD, ë°©í–¥í‚¤)
// =========================
document.addEventListener("keydown", (e) => {
  let key = e.key;
  let cell = grid[player.r][player.c];

  if ((key === "w" || key === "ArrowUp") && !cell.walls.top) player.r--;
  if ((key === "s" || key === "ArrowDown") && !cell.walls.bottom) player.r++;
  if ((key === "a" || key === "ArrowLeft") && !cell.walls.left) player.c--;
  if ((key === "d" || key === "ArrowRight") && !cell.walls.right) player.c++;

  drawMaze();
  checkWin();
});


// =========================
// ìŠ¹ë¦¬ íŒì •
// =========================
function checkWin() {
  if (player.r === exit.r && player.c === exit.c) {
    setTimeout(() => alert("ğŸ‰ ë¯¸ê¶ íƒˆì¶œ ì„±ê³µ!"), 50);
  }
}


// =========================
// ê²Œì„ ì´ˆê¸°í™”
// =========================
function newGame() {
  generateMaze();
  player = { r: 0, c: 0 };
  exit = { r: rows - 1, c: cols - 1 };

  resizeCanvas();
  drawMaze();
}

document.getElementById("generateBtn").onclick = newGame;


// =========================
// ì´ˆê¸° 2ë‹¨ê³„ ë Œë”ë§ (ë²„ê·¸ ë°©ì§€)
// =========================
window.onload = () => {
  resizeCanvas();
  setTimeout(() => {
    resizeCanvas();
    newGame();
  }, 80);
};


// =========================
// ğŸ•¹ ì¡°ì´ìŠ¤í‹±
// =========================
const joy = document.getElementById("joystick");
const stick = document.getElementById("stick");

let joyCenter = { x: 0, y: 0 };
let dragging = false;

function simulateKey(key){
  const e = new KeyboardEvent("keydown",{key:key});
  document.dispatchEvent(e);
}

joy.addEventListener("pointerdown", e=>{
  dragging = true;
  joyCenter = {
    x: joy.offsetLeft + joy.offsetWidth/2,
    y: joy.offsetTop + joy.offsetHeight/2
  };
});

document.addEventListener("pointermove", e=>{
  if(!dragging) return;
  let dx = e.clientX - joyCenter.x;
  let dy = e.clientY - joyCenter.y;

  const maxDist = 40;
  let ang = Math.atan2(dy, dx);
  let dist = Math.min(maxDist, Math.sqrt(dx*dx + dy*dy));

  let sx = Math.cos(ang) * dist;
  let sy = Math.sin(ang) * dist;

  stick.style.left = `${40 + sx}px`;
  stick.style.top  = `${40 + sy}px`;

  if(Math.abs(dx) > Math.abs(dy)) {
    if(dx > 10) simulateKey("d");
    else if(dx < -10) simulateKey("a");
  } else {
    if(dy > 10) simulateKey("s");
    else if(dy < -10) simulateKey("w");
  }
});

document.addEventListener("pointerup", ()=>{
  dragging = false;
  stick.style.left = "40px";
  stick.style.top  = "40px";
});
</script>

</body>
</html>

