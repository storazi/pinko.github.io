<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0" />
<title>âš« ì˜¤ëª© AI (ë Œì£¼ë£°)</title>

<style>
/* ===============================
   ê¸°ë³¸ ìŠ¤íƒ€ì¼
================================ */
body {
  margin: 0;
  background: #0b1220;
  color: #fff;
  text-align: center;
  font-family: "Pretendard", sans-serif;
}

h1 {
  margin-top: 15px;
  color: #ffd447;
  font-size: 28px;
}

.option-bar {
  margin: 12px auto;
  display: flex;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
}

.option-bar label {
  cursor: pointer;
  font-size: 15px;
}

#resetBtn {
  background: #ffd447;
  color: #111;
  padding: 8px 14px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-weight: bold;
}

#statusBox {
  margin: 10px auto;
  padding: 10px;
  width: min(90%, 600px);
  background: #11234a;
  border-left: 6px solid #ffd447;
  border-radius: 8px;
  text-align: left;
  font-size: 15px;
}

/* =======================================
   ğŸ“Œ ë°˜ì‘í˜• ë³´ë“œ ì»¨í…Œì´ë„ˆ
======================================= */
#boardContainer {
  width: 100%;
  margin-top: 10px;
  display: flex;
  justify-content: center;
}

#boardWrapper {
  position: relative;
  width: min(95vw, 600px);
  height: min(95vw, 600px);
}

/* =======================================
   ğŸ“Œ ì˜¤ëª©íŒ
======================================= */
#board {
  width: 100%;
  height: 100%;
  background: #b67a3d;
  border: 10px solid #dba56a;
  border-radius: 8px;
  box-sizing: border-box;

  background-image:
    linear-gradient(#000 2px, transparent 2px),
    linear-gradient(to right, #000 2px, transparent 2px);
  background-size: calc(100% / 15) calc(100% / 15);
}

/* í´ë¦­ í¬ì¸íŠ¸ */
.point {
  position: absolute;
  width: calc(100% / 15);
  height: calc(100% / 15);
  transform: translate(-50%, -50%);
  cursor: pointer;
}

/* ëŒ */
.stone {
  position: absolute;
  width: calc(100% / 15 * 0.82);
  height: calc(100% / 15 * 0.82);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 6px rgba(0,0,0,0.5);
}

.stone.black { background: radial-gradient(circle at 30% 30%, #444, #000); }
.stone.white { background: radial-gradient(circle at 30% 30%, #fff, #ccc); }

/* ê¸ˆìˆ˜ í‘œì‹œ */
.ban {
  position: absolute;
  width: calc(100% / 15 * 0.55);
  height: calc(100% / 15 * 0.55);
  background: rgba(255,255,255,0.7);
  color: red;
  border-radius: 4px;
  font-size: calc(100% / 15 * 0.38);
  text-align: center;
  line-height: calc(100% / 15 * 0.55);
  transform: translate(-50%, -50%);
  pointer-events: none;
}

/* ===== ğŸ”¥ ì°©ìˆ˜ ë¯¸ë¦¬ë³´ê¸° ëŒ ===== */
#ghostStone {
  position: absolute;
  width: calc(100% / 15 * 0.82);
  height: calc(100% / 15 * 0.82);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  opacity: 0;
  pointer-events: none;
  z-index: 20;
}

#ghostStone.black { background: rgba(0,0,0,0.4); }
#ghostStone.white { background: rgba(255,255,255,0.5); }

#ghostStone.forbidden {
  background: none;
  border: 3px solid red;
}
</style>
</head>


<body>
<h1>âš« ì˜¤ëª© AI (ë Œì£¼ë£°)</h1>

<div class="option-bar">
  <label><input type="radio" name="firstPlayer" value="human" checked> ì‚¬ëŒì´ í‘(ì„ ê³µ)</label>
  <label><input type="radio" name="firstPlayer" value="ai"> AI ì„ ê³µ</label>
  <span style="margin:0 10px;"></span>
  <label><input type="radio" name="difficulty" value="normal" checked> ë³´í†µ</label>
  <label><input type="radio" name="difficulty" value="hard"> ì–´ë ¤ì›€</label>
  <button id="resetBtn">ìƒˆ ê²Œì„</button>
</div>

<div id="statusBox">ì¤€ë¹„ ì¤‘...</div>

<div id="boardContainer">
  <div id="boardWrapper">
    <div id="board"></div>
    <div id="ghostStone"></div>
  </div>
</div>

<script>
/* ============================================================
   âš« ì˜¤ëª© AI (ë Œì£¼ë£°) - ì „ì²´ ë¡œì§
============================================================ */

const SIZE  = 15;
const EMPTY = 0;
const BLACK = 1;
const WHITE = 2;

let board      = [];
let humanColor = BLACK;
let aiColor    = WHITE;
let turn       = BLACK;
let gameOver   = false;

let ghost; // ë¯¸ë¦¬ë³´ê¸° ëŒ ì—˜ë¦¬ë¨¼íŠ¸

/* ============================
   ì´ˆê¸° ì‹¤í–‰
============================ */
window.onload = () => {
  ghost = document.getElementById("ghostStone");
  document.getElementById("resetBtn").onclick = startGame;
  startGame();
};

/* ============================
   ê²Œì„ ì‹œì‘ / ì¬ì‹œì‘
============================ */
function startGame() {
  initBoard();
  createBoardUI();
  renderBoard();

  const first = document.querySelector("input[name=firstPlayer]:checked").value;
  humanColor = (first === "human" ? BLACK : WHITE);
  aiColor    = (humanColor === BLACK ? WHITE : BLACK);

  turn = BLACK;
  gameOver = false;
  setStatus("ìƒˆ ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.");

  if (first === "ai") {
    aiStartMove();
  }
}

/* ============================
   ë³´ë“œ ë°ì´í„° ì´ˆê¸°í™”
============================ */
function initBoard() {
  board = Array.from({ length: SIZE }, () => Array(SIZE).fill(EMPTY));
}

/* ============================
   í´ë¦­ í¬ì¸íŠ¸ UI ìƒì„±
============================ */
function createBoardUI() {
  const bd = document.getElementById("board");
  bd.innerHTML = "";
  ghost.style.opacity = 0;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const p = document.createElement("div");
      p.className = "point";
      p.dataset.x = x;
      p.dataset.y = y;

      // í¼ì„¼íŠ¸ ì¢Œí‘œ (ë°˜ì‘í˜•)
      p.style.left = ((x + 0.5) * (100 / SIZE)) + "%";
      p.style.top  = ((y + 0.5) * (100 / SIZE)) + "%";

      p.addEventListener("click", onHumanClick);
      p.addEventListener("mousemove", onHover);
      p.addEventListener("mouseleave", () => ghost.style.opacity = 0);

      bd.appendChild(p);
    }
  }
}

/* ============================
   ë³´ë“œ ë Œë”ë§
============================ */
function renderBoard() {
  const bd = document.getElementById("board");

  // ëŒ / ê¸ˆìˆ˜ ì´ˆê¸°í™”
  document.querySelectorAll(".stone").forEach(s => s.remove());
  document.querySelectorAll(".ban").forEach(b => b.remove());

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const v = board[y][x];

      // ëŒ ë Œë”ë§
      if (v === BLACK || v === WHITE) {
        const s = document.createElement("div");
        s.className = "stone " + (v === BLACK ? "black" : "white");
        s.style.left = ((x + 0.5) * (100 / SIZE)) + "%";
        s.style.top  = ((y + 0.5) * (100 / SIZE)) + "%";
        bd.appendChild(s);
      }

      // ê¸ˆìˆ˜ í‘œì‹œ (í˜„ì¬ í„´ì´ í‘ì¼ ë•Œë§Œ)
      if (turn === BLACK && v === EMPTY && isForbidden(board, x, y)) {
        const b = document.createElement("div");
        b.className = "ban";
        b.textContent = "X";
        b.style.left = ((x + 0.5) * (100 / SIZE)) + "%";
        b.style.top  = ((y + 0.5) * (100 / SIZE)) + "%";
        bd.appendChild(b);
      }
    }
  }
}

/* ============================
   ë¯¸ë¦¬ë³´ê¸° ëŒ (hover)
============================ */
function onHover(e) {
  if (gameOver) return;
  if (turn !== humanColor) return;

  const x = +e.target.dataset.x;
  const y = +e.target.dataset.y;

  ghost.style.opacity = 1;
  ghost.style.left = e.target.style.left;
  ghost.style.top  = e.target.style.top;

  ghost.className = "";
  ghost.classList.add(humanColor === BLACK ? "black" : "white");

  if (humanColor === BLACK && isForbidden(board, x, y)) {
    ghost.classList.add("forbidden");
  }
}

/* ============================
   ì‚¬ëŒ ì°©ìˆ˜
============================ */
function onHumanClick(e) {
  if (gameOver) return;
  if (turn !== humanColor) return;

  const x = +e.target.dataset.x;
  const y = +e.target.dataset.y;

  if (board[y][x] !== EMPTY) return;

  if (turn === BLACK && isForbidden(board, x, y)) {
    setStatus("âš  ê¸ˆìˆ˜ ìë¦¬ì…ë‹ˆë‹¤!");
    return;
  }

  placeStone(x, y, humanColor);
  ghost.style.opacity = 0;

  if (checkWin(humanColor)) {
    setStatus("ğŸ‰ ë‹¹ì‹ ì˜ ìŠ¹ë¦¬!");
    gameOver = true;
    renderBoard();
    return;
  }

  turn = aiColor;
  renderBoard();
  aiStartMove();
}

/* ============================
   ëŒ ë†“ê¸°
============================ */
function placeStone(x, y, color) {
  board[y][x] = color;
}

/* ============================
   AI ì°©ìˆ˜ ì‹œì‘
============================ */
async function aiStartMove() {
  if (gameOver) return;

  setStatus("AI ìƒê° ì¤‘...");
  await new Promise(r => setTimeout(r, 80));

  const diff = document.querySelector("input[name=difficulty]:checked").value;
  let mv = (diff === "normal" ? aiMove_B() : aiMove_C());

  if (!mv) {
    setStatus("ë¬´ìŠ¹ë¶€!");
    return;
  }

  // ê¸ˆìˆ˜ íšŒí”¼
  if (aiColor === BLACK && isForbidden(board, mv.x, mv.y)) {
    mv = findNonForbiddenMove();
    if (!mv) {
      setStatus("ë¬´ìŠ¹ë¶€!");
      return;
    }
  }

  placeStone(mv.x, mv.y, aiColor);

  if (checkWin(aiColor)) {
    setStatus("ğŸ’€ AI ìŠ¹ë¦¬!");
    gameOver = true;
    renderBoard();
    return;
  }

  turn = humanColor;
  setStatus("ë‹¹ì‹  ì°¨ë¡€ì…ë‹ˆë‹¤.");
  renderBoard();
}

/* ============================
   ê¸ˆìˆ˜ ì•„ë‹Œ ëŒ€ì²´ ì°©ìˆ˜
============================ */
function findNonForbiddenMove() {
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] === EMPTY && !isForbidden(board, x, y)) {
        return { x, y };
      }
    }
  }
  return null;
}

/* ============================
   B ë‚œì´ë„ (ê¸°ë³¸)
============================ */
function aiMove_B() {
  // 1) AIì˜ ì¦‰ìŠ¹
  let win = findWinningMove(aiColor);
  if (win) return win;

  // 2) ìƒëŒ€ì˜ ì¦‰ìŠ¹ ì°¨ë‹¨
  let block = findWinningMove(humanColor);
  if (block) return block;

  // 3) AI ê°•ì œ 4 ìˆ˜
  let f = findForceMove(aiColor);
  if (f) return f;

  // 4) ìƒëŒ€ ê°•ì œ 4 ìˆ˜ ì°¨ë‹¨
  let fb = findForceMove(humanColor);
  if (fb) return fb;

  // 5) ì „ëµ ìœ„ì¹˜
  return chooseStrategicMove(false);
}

/* ============================
   C ë‚œì´ë„ (ë” ë˜‘ë˜‘)
============================ */
function aiMove_C() {
  // 1) AI ì¦‰ìŠ¹
  let win = findWinningMove(aiColor);
  if (win) return win;

  // 2) ìƒëŒ€ ì¦‰ìŠ¹ ì°¨ë‹¨
  let block = findWinningMove(humanColor);
  if (block) return block;

  // 3) AI ë”ë¸” ì“°ë ˆíŠ¸
  let dual = findDoubleThreat(aiColor);
  if (dual) return dual;

  // 4) ìƒëŒ€ ë”ë¸” ì“°ë ˆíŠ¸ ì°¨ë‹¨
  let dualBlock = findDoubleThreat(humanColor);
  if (dualBlock) return dualBlock;

  // 5) ê°•ì œ 4
  let f = findForceMove(aiColor);
  if (f) return f;

  let fb = findForceMove(humanColor);
  if (fb) return fb;

  // 6) ì „ëµ ìœ„ì¹˜
  return chooseStrategicMove(true);
}

/* ============================
   ìŠ¹ë¦¬ ìˆ˜ íƒìƒ‰
============================ */
function findWinningMove(color) {
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (color === BLACK && isForbidden(board, x, y)) continue;

      board[y][x] = color;
      let win = checkWin(color);
      board[y][x] = EMPTY;

      if (win) return { x, y };
    }
  }
  return null;
}

/* ============================
   ê°•ì œ 4 ìˆ˜ ì°¾ê¸°
============================ */
function findForceMove(color) {
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  let best = null, bestScore = 0;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (color === BLACK && isForbidden(board, x, y)) continue;

      let score = 0;
      for (const [dx, dy] of dirs) {
        let c = countSeq(board, x, y, dx, dy, color);
        if (c === 4) score += 100000;
        else if (c === 3) score += 800;
      }

      if (score > bestScore) {
        bestScore = score;
        best = { x, y };
      }
    }
  }
  return best;
}

/* ============================
   ë”ë¸” ì“°ë ˆíŠ¸ (C ë‚œì´ë„)
============================ */
function findDoubleThreat(color) {
  let cntBest = 0;
  let bestMove = null;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (color === BLACK && isForbidden(board, x, y)) continue;

      board[y][x] = color;
      let f1 = findForceMove(color);
      let cnt = f1 ? 1 : 0;
      board[y][x] = EMPTY;

      if (cnt > cntBest) {
        cntBest = cnt;
        bestMove = { x, y };
      }
    }
  }
  return bestMove;
}

/* ============================
   ì „ëµ ìœ„ì¹˜ ì„ íƒ
============================ */
function chooseStrategicMove(hardMode) {
  let best = null;
  let bestScore = -Infinity;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (aiColor === BLACK && isForbidden(board, x, y)) continue;

      let score = 0;

      // ì¤‘ì‹¬ ê°€ì¤‘ì¹˜
      const dist = Math.abs(x - 7) + Math.abs(y - 7);
      score += (hardMode ? 30 : 18) - dist;

      // ì£¼ë³€ ì˜í–¥
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          let nx = x + dx, ny = y + dy;
          if (!isIn(nx, ny)) continue;

          if (board[ny][nx] === aiColor)    score += (hardMode ? 14 : 10);
          if (board[ny][nx] === humanColor) score += (hardMode ? 11 : 7);
        }
      }

      if (score > bestScore) {
        bestScore = score;
        best = { x, y };
      }
    }
  }
  return best;
}

<!-- ============================
     âš«  ì˜¤ëª© AI â€” 2/2 ì½”ë“œ
============================ -->

<script>
/* ============================
   ìŠ¹ë¦¬ íŒì •
============================ */
function checkWin(color) {
  const dirs = [
    [1, 0],   // â†’
    [0, 1],   // â†“
    [1, 1],   // â†˜
    [1, -1]   // â†—
  ];

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== color) continue;

      for (const [dx, dy] of dirs) {
        let cnt = 1;

        // ì •ë°©í–¥
        let nx = x + dx, ny = y + dy;
        while (isIn(nx, ny) && board[ny][nx] === color) {
          cnt++;
          nx += dx;
          ny += dy;
        }

        // ì—­ë°©í–¥
        nx = x - dx; ny = y - dy;
        while (isIn(nx, ny) && board[ny][nx] === color) {
          cnt++;
          nx -= dx;
          ny -= dy;
        }

        if (cnt >= 5) return true;
      }
    }
  }
  return false;
}

/* ============================
   ê¸ˆìˆ˜ ê²€ì‚¬ (ë Œì£¼ë£°)
============================ */
function isForbidden(bd, x, y) {
  if (bd[y][x] !== EMPTY) return true;  // ì´ë¯¸ ëŒ ìˆìŒ â†’ ê¸ˆìˆ˜

  bd[y][x] = BLACK;

  const over6  = isOverline(bd, x, y);
  const open3  = countOpenThree(bd, x, y) >= 2;
  const open4  = countOpenFour(bd, x, y) >= 2;

  bd[y][x] = EMPTY;

  return over6 || open3 || open4;
}

/* ============================
   6ëª© ì´ìƒ ì²´í¬ (ì¥ëª©)
============================ */
function isOverline(bd, x, y) {
  return (
    countSeq(bd, x, y, 1, 0, BLACK) >= 6 ||
    countSeq(bd, x, y, 0, 1, BLACK) >= 6 ||
    countSeq(bd, x, y, 1, 1, BLACK) >= 6 ||
    countSeq(bd, x, y, 1, -1, BLACK) >= 6
  );
}

/* ============================
   ì—°ì† ëŒ ê°œìˆ˜ ì„¸ê¸°
============================ */
function countSeq(bd, x, y, dx, dy, color) {
  let cnt = 1;

  // ì •ë°©í–¥
  let nx = x + dx, ny = y + dy;
  while (isIn(nx, ny) && bd[ny][nx] === color) {
    cnt++;
    nx += dx;
    ny += dy;
  }

  // ì—­ë°©í–¥
  nx = x - dx; ny = y - dy;
  while (isIn(nx, ny) && bd[ny][nx] === color) {
    cnt++;
    nx -= dx;
    ny -= dy;
  }

  return cnt;
}

/* ============================
   íŒ¨í„´ ê²€ì‚¬ ìœ í‹¸
============================ */
function countPattern(bd, x, y, targetPattern) {
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  let cnt = 0;

  for (const [dx, dy] of dirs) {
    let line = "";

    for (let k = -4; k <= 4; k++) {
      let nx = x + dx * k;
      let ny = y + dy * k;

      if (!isIn(nx, ny)) {
        line += "3"; // ë°”ê¹¥ í‘œê¸°
      } else {
        line += (
          bd[ny][nx] === BLACK ? "1" :
          bd[ny][nx] === WHITE ? "2" : "0"
        );
      }
    }

    if (line.includes(targetPattern)) cnt++;
  }
  return cnt;
}

/* ============================
   ì—´ë¦° 3 / ì—´ë¦° 4
============================ */
function countOpenThree(bd, x, y) {
  return countPattern(bd, x, y, "01110");
}

function countOpenFour(bd, x, y) {
  return countPattern(bd, x, y, "011110");
}

/* ============================
   ë²”ìœ„ ì²´í¬
============================ */
function isIn(x, y) {
  return (x >= 0 && y >= 0 && x < SIZE && y < SIZE);
}

/* ============================
   ìƒíƒœ ë©”ì‹œì§€
============================ */
function setStatus(msg) {
  document.getElementById("statusBox").textContent = msg;
}

</script>

</html>

    
</script>
</body>
</html>

