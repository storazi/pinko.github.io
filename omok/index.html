<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0" />
<title>âš« ì˜¤ëª© AI (ë Œì£¼ë£°)</title>

<style>
/* ===============================
   ê¸°ë³¸ ìŠ¤íƒ€ì¼
================================ */
body {
  margin: 0;
  background: #0b1220;
  color: #fff;
  text-align: center;
  font-family: "Pretendard", sans-serif;
}

h1 {
  margin-top: 15px;
  color: #ffd447;
  font-size: 28px;
}

.option-bar {
  margin: 12px auto;
  display: flex;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
}

.option-bar label {
  cursor: pointer;
  font-size: 15px;
}

#resetBtn {
  background: #ffd447;
  color: #111;
  padding: 8px 14px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-weight: bold;
}

#statusBox {
  margin: 10px auto;
  padding: 10px;
  width: min(90%, 600px);
  background: #11234a;
  border-left: 6px solid #ffd447;
  border-radius: 8px;
  text-align: left;
  font-size: 15px;
}

/* =======================================
   ğŸ“Œ ë°˜ì‘í˜• ë³´ë“œ ì»¨í…Œì´ë„ˆ
======================================= */
#boardContainer {
  width: 100%;
  margin-top: 10px;
  display: flex;
  justify-content: center;
}

#boardWrapper {
  position: relative;
  width: min(95vw, 600px);
  height: min(95vw, 600px);
}

/* =======================================
   ğŸ“Œ ì˜¤ëª©íŒ
======================================= */
#board {
  width: 100%;
  height: 100%;
  background: #b67a3d;
  border: 10px solid #dba56a;
  border-radius: 8px;
  box-sizing: border-box;

  background-image:
    linear-gradient(#000 2px, transparent 2px),
    linear-gradient(to right, #000 2px, transparent 2px);
  background-size: calc(100% / 15) calc(100% / 15);
}

/* í´ë¦­ í¬ì¸íŠ¸ */
.point {
  position: absolute;
  width: calc(100% / 15);
  height: calc(100% / 15);
  transform: translate(-50%, -50%);
  cursor: pointer;
}

/* ëŒ */
.stone {
  position: absolute;
  width: calc(100% / 15 * 0.82);
  height: calc(100% / 15 * 0.82);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 6px rgba(0,0,0,0.5);
}

.stone.black { background: radial-gradient(circle at 30% 30%, #444, #000); }
.stone.white { background: radial-gradient(circle at 30% 30%, #fff, #ccc); }

/* ê¸ˆìˆ˜ í‘œì‹œ */
.ban {
  position: absolute;
  width: calc(100% / 15 * 0.55);
  height: calc(100% / 15 * 0.55);
  background: rgba(255,255,255,0.7);
  color: red;
  border-radius: 4px;
  font-size: calc(100% / 15 * 0.38);
  text-align: center;
  line-height: calc(100% / 15 * 0.55);
  transform: translate(-50%, -50%);
  pointer-events: none;
}

/* ===== ğŸ”¥ ì°©ìˆ˜ ë¯¸ë¦¬ë³´ê¸° ëŒ ===== */
#ghostStone {
  position: absolute;
  width: calc(100% / 15 * 0.82);
  height: calc(100% / 15 * 0.82);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  opacity: 0;
  pointer-events: none;
  z-index: 20;
}

#ghostStone.black { background: rgba(0,0,0,0.4); }
#ghostStone.white { background: rgba(255,255,255,0.5); }

#ghostStone.forbidden {
  background: none;
  border: 3px solid red;
}
</style>
</head>


<body>
<h1>âš« ì˜¤ëª© AI (ë Œì£¼ë£°)</h1>

<div class="option-bar">
  <label><input type="radio" name="firstPlayer" value="human" checked> ì‚¬ëŒì´ í‘(ì„ ê³µ)</label>
  <label><input type="radio" name="firstPlayer" value="ai"> AI ì„ ê³µ</label>
  <span style="margin:0 10px;"></span>
  <label><input type="radio" name="difficulty" value="normal" checked> ë³´í†µ</label>
  <label><input type="radio" name="difficulty" value="hard"> ì–´ë ¤ì›€</label>
  <button id="resetBtn">ìƒˆ ê²Œì„</button>
</div>

<div id="statusBox">ì¤€ë¹„ ì¤‘...</div>

<div id="boardContainer">
  <div id="boardWrapper">
    <div id="board"></div>
    <div id="ghostStone"></div>
  </div>
</div>

<script>
/* ============================================================
   âš« ì˜¤ëª© AI (ë Œì£¼ë£°) - ì „ì²´ ë¡œì§
============================================================ */

const SIZE  = 15;
const EMPTY = 0;
const BLACK = 1;
const WHITE = 2;

let board      = [];
let humanColor = BLACK;
let aiColor    = WHITE;
let turn       = BLACK;
let gameOver   = false;

let ghost;

/* ========== ì´ˆê¸° ì‹¤í–‰ ========== */
window.onload = () => {
  ghost = document.getElementById("ghostStone");
  document.getElementById("resetBtn").onclick = startGame;
  startGame();
};

/* ========== ê²Œì„ ì‹œì‘ ========== */
function startGame() {
  initBoard();
  createBoardUI();
  renderBoard();

  const first = document.querySelector("input[name=firstPlayer]:checked").value;

  humanColor = (first === "human" ? BLACK : WHITE);
  aiColor    = (humanColor === BLACK ? WHITE : BLACK);

  turn = BLACK;
  gameOver = false;
  setStatus("ìƒˆ ê²Œì„ ì‹œì‘!");

  if (first === "ai") aiStartMove();
}

/* ========== ë³´ë“œ ìƒì„± ========== */
function initBoard() {
  board = Array.from({ length: SIZE }, () => Array(SIZE).fill(EMPTY));
}

function createBoardUI() {
  const bd = document.getElementById("board");
  bd.innerHTML = "";
  ghost.style.opacity = 0;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const p = document.createElement("div");
      p.className = "point";
      p.dataset.x = x;
      p.dataset.y = y;

      p.style.left = ((x + 0.5) * (100 / SIZE)) + "%";
      p.style.top  = ((y + 0.5) * (100 / SIZE)) + "%";

      p.addEventListener("click", onHumanClick);
      p.addEventListener("mousemove", onHover);
      p.addEventListener("mouseleave", () => ghost.style.opacity = 0);

      bd.appendChild(p);
    }
  }
}

/* ========== ë Œë”ë§ ========== */
function renderBoard() {
  const bd = document.getElementById("board");

  document.querySelectorAll(".stone").forEach(s => s.remove());
  document.querySelectorAll(".ban").forEach(b => b.remove());

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const v = board[y][x];

      if (v === BLACK || v === WHITE) {
        const s = document.createElement("div");
        s.className = "stone " + (v === BLACK ? "black" : "white");
        s.style.left = ((x + 0.5) * (100 / SIZE)) + "%";
        s.style.top  = ((y + 0.5) * (100 / SIZE)) + "%";
        bd.appendChild(s);
      }

      if (turn === BLACK && v === EMPTY && isForbidden(board, x, y)) {
        const b = document.createElement("div");
        b.className = "ban";
        b.textContent = "X";
        b.style.left = ((x + 0.5) * (100 / SIZE)) + "%";
        b.style.top  = ((y + 0.5) * (100 / SIZE)) + "%";
        bd.appendChild(b);
      }
    }
  }
}

/* ========== ë¯¸ë¦¬ë³´ê¸° ëŒ ========== */
function onHover(e) {
  if (gameOver || turn !== humanColor) return;

  const x = +e.target.dataset.x;
  const y = +e.target.dataset.y;

  ghost.style.opacity = 1;
  ghost.style.left = e.target.style.left;
  ghost.style.top  = e.target.style.top;

  ghost.className = "";
  ghost.classList.add(humanColor === BLACK ? "black" : "white");

  if (humanColor === BLACK && isForbidden(board, x, y)) {
    ghost.classList.add("forbidden");
  }
}

/* ========== ì‚¬ëŒ ì°©ìˆ˜ ========== */
function onHumanClick(e) {
  if (gameOver || turn !== humanColor) return;

  const x = +e.target.dataset.x;
  const y = +e.target.dataset.y;

  if (board[y][x] !== EMPTY) return;

  if (turn === BLACK && isForbidden(board, x, y)) {
    setStatus("âš  ê¸ˆìˆ˜ ìë¦¬ì…ë‹ˆë‹¤!");
    return;
  }

  placeStone(x, y, humanColor);
  ghost.style.opacity = 0;

  if (checkWin(humanColor)) {
    gameOver = true;
    setStatus("ğŸ‰ ë‹¹ì‹ ì˜ ìŠ¹ë¦¬!");
    renderBoard();
    return;
  }

  turn = aiColor;
  renderBoard();
  aiStartMove();
}

/* ========== ëŒ ë†“ê¸° ========== */
function placeStone(x, y, color) {
  board[y][x] = color;
}

/* ========== AI ì°©ìˆ˜ ========== */
async function aiStartMove() {
  if (gameOver) return;

  setStatus("AI ìƒê° ì¤‘...");
  await new Promise(r => setTimeout(r, 90));

  const diff = document.querySelector("input[name=difficulty]:checked").value;
  let mv = (diff === "normal" ? aiMove_B() : aiMove_C());

  if (!mv) {
    setStatus("ë¬´ìŠ¹ë¶€!");
    return;
  }

  if (aiColor === BLACK && isForbidden(board, mv.x, mv.y)) {
    mv = findNonForbiddenMove();
    if (!mv) {
      setStatus("ë¬´ìŠ¹ë¶€!");
      return;
    }
  }

  placeStone(mv.x, mv.y, aiColor);

  if (checkWin(aiColor)) {
    gameOver = true;
    setStatus("ğŸ’€ AI ìŠ¹ë¦¬!");
    renderBoard();
    return;
  }

  turn = humanColor;
  setStatus("ë‹¹ì‹  ì°¨ë¡€ì…ë‹ˆë‹¤.");
  renderBoard();
}

/* ========== ê¸ˆìˆ˜ ì•„ë‹Œ ëŒ€ì²´ ìë¦¬ ========== */
function findNonForbiddenMove() {
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] === EMPTY && !isForbidden(board, x, y)) {
        return { x, y };
      }
    }
  }
  return null;
}

/* ========================================
   AI ì•Œê³ ë¦¬ì¦˜ (B, C ë‚œì´ë„)
======================================== */

function aiMove_B() {
  let win = findWinningMove(aiColor);
  if (win) return win;

  let block = findWinningMove(humanColor);
  if (block) return block;

  let f = findForceMove(aiColor);
  if (f) return f;

  let fb = findForceMove(humanColor);
  if (fb) return fb;

  return chooseStrategicMove(false);
}

function aiMove_C() {
  let win = findWinningMove(aiColor);
  if (win) return win;

  let block = findWinningMove(humanColor);
  if (block) return block;

  let dual = findDoubleThreat(aiColor);
  if (dual) return dual;

  let dualBlock = findDoubleThreat(humanColor);
  if (dualBlock) return dualBlock;

  let f = findForceMove(aiColor);
  if (f) return f;

  let fb = findForceMove(humanColor);
  if (fb) return fb;

  return chooseStrategicMove(true);
}

function findWinningMove(color) {
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (color === BLACK && isForbidden(board, x, y)) continue;

      board[y][x] = color;
      let win = checkWin(color);
      board[y][x] = EMPTY;

      if (win) return { x, y };
    }
  }
  return null;
}

function findForceMove(color) {
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  let best = null, scoreBest = 0;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (color === BLACK && isForbidden(board, x, y)) continue;

      let score = 0;

      for (const [dx, dy] of dirs) {
        let c = countSeq(board, x, y, dx, dy, color);
        if (c === 4) score += 100000;
        else if (c === 3) score += 800;
      }

      if (score > scoreBest) {
        scoreBest = score;
        best = { x, y };
      }
    }
  }
  return best;
}

function findDoubleThreat(color) {
  let best = null;
  let maxCount = 0;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (color === BLACK && isForbidden(board, x, y)) continue;

      board[y][x] = color;
      let f = findForceMove(color);
      let cnt = f ? 1 : 0;
      board[y][x] = EMPTY;

      if (cnt > maxCount) {
        maxCount = cnt;
        best = { x, y };
      }
    }
  }
  return best;
}

function chooseStrategicMove(hardMode) {
  let best = null;
  let bestScore = -Infinity;

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== EMPTY) continue;
      if (aiColor === BLACK && isForbidden(board, x, y)) continue;

      let score = 0;
      const dist = Math.abs(x - 7) + Math.abs(y - 7);

      score += (hardMode ? 30 : 18) - dist;

      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          let nx = x + dx, ny = y + dy;
          if (!isIn(nx, ny)) continue;

          if (board[ny][nx] === aiColor) score += (hardMode ? 14 : 10);
          if (board[ny][nx] === humanColor) score += (hardMode ? 11 : 7);
        }
      }

      if (score > bestScore) {
        bestScore = score;
        best = { x, y };
      }
    }
  }
  return best;
}

/* ========================================
   ğŸ ìŠ¹ë¦¬ íŒì • & ê¸ˆìˆ˜ ê²€ì‚¬
======================================== */

function checkWin(color) {
  const dirs = [
    [1, 0],
    [0, 1],
    [1, 1],
    [1, -1],
  ];

  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== color) continue;

      for (const [dx, dy] of dirs) {
        let cnt = 1;

        let nx = x + dx, ny = y + dy;
        while (isIn(nx, ny) && board[ny][nx] === color) {
          cnt++;
          nx += dx;
          ny += dy;
        }

        nx = x - dx;
        ny = y - dy;
        while (isIn(nx, ny) && board[ny][nx] === color) {
          cnt++;
          nx -= dx;
          ny -= dy;
        }

        if (cnt >= 5) return true;
      }
    }
  }
  return false;
}

function isForbidden(bd, x, y) {
  if (bd[y][x] !== EMPTY) return true;

  bd[y][x] = BLACK;

  const over6 = isOverline(bd, x, y);
  const open3 = countOpenThree(bd, x, y) >= 2;
  const open4 = countOpenFour(bd, x, y) >= 2;

  bd[y][x] = EMPTY;

  return over6 || open3 || open4;
}

function isOverline(bd, x, y) {
  return (
    countSeq(bd, x, y, 1, 0, BLACK) >= 6 ||
    countSeq(bd, x, y, 0, 1, BLACK) >= 6 ||
    countSeq(bd, x, y, 1, 1, BLACK) >= 6 ||
    countSeq(bd, x, y, 1, -1, BLACK) >= 6
  );
}

function countSeq(bd, x, y, dx, dy, color) {
  let cnt = 1;
  let nx = x + dx, ny = y + dy;

  while (isIn(nx, ny) && bd[ny][nx] === color) {
    cnt++;
    nx += dx;
    ny += dy;
  }

  nx = x - dx;
  ny = y - dy;

  while (isIn(nx, ny) && bd[ny][nx] === color) {
    cnt++;
    nx -= dx;
    ny -= dy;
  }

  return cnt;
}

function countPattern(bd, x, y, pattern) {
  const dirs = [
    [1, 0], [0, 1], [1, 1], [1, -1]
  ];
  let cnt = 0;

  for (const [dx, dy] of dirs) {
    let line = "";

    for (let k = -4; k <= 4; k++) {
      let nx = x + dx * k;
      let ny = y + dy * k;

      if (!isIn(nx, ny)) line += "3";
      else line += (bd[ny][nx] === BLACK ? "1"
              : bd[ny][nx] === WHITE ? "2" : "0");
    }

    if (line.includes(pattern)) cnt++;
  }
  return cnt;
}

function countOpenThree(bd, x, y) {
  return countPattern(bd, x, y, "01110");
}

function countOpenFour(bd, x, y) {
  return countPattern(bd, x, y, "011110");
}

function isIn(x, y) {
  return x >= 0 && y >= 0 && x < SIZE && y < SIZE;
}

/* ========================================
   ì¶œë ¥
======================================== */
function setStatus(msg) {
  document.getElementById("statusBox").textContent = msg;
}
</script>

<footer style="text-align:center; margin-top:20px; opacity:0.8;">
  <img src="https://hits.sh/atorazi.github.io/291.svg?color=f3ff00&labelColor=111ca8">
</footer>

</body>
</html>
